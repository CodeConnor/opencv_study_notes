'''
案例：在一个宽、高都为200像素的纯白色图像中，绘制一个半径为20像素的纯蓝色小球。让小球做匀速直线运动，一旦圆形碰触到图像边界则开始反弹（反弹不损失动能）
分析：
小球在运动的过程中可以把移动速度划分为上、下、左、右4个方向。
左右为横坐标移动速度，上下为纵坐标移动速度。
小球向右移动时横坐标不断变大，向左移动时横坐标不断变小，由此可以认为：小球向右的移动速度为正，向左的移动速度为负。
纵坐标同理，因为图像坐标系的原点为背景左上角顶点，越往下延伸纵坐标越大，所以小球向上的移动速度为负，向下的移动速度为正。
只需要改变速度的正负号小球就可以改变移动方向，所以在程序中可以将小球的横坐标速度和纵坐标速度设定成一个不变的值，
每次小球碰到左右边界，就更改横坐标速度的正负号，碰到上下边界，就更改纵坐标速度的正负号。
动画实际上是由多幅画面在短时间内交替放映实现的视觉效果。
每一幅画面被称为一帧，所谓的60帧就是指1s放映了60幅画面。
使用time模块中sleep()方法，实现每（1/60）s计算一次小球的移动轨迹，并将移动后的结果绘制到图像上，
这样1s有60幅图像交替放映，就可以看到弹球的动画效果了。
'''

import numpy as np
import cv2
import time

width = height = 200  # 画布宽和高
r = 20  # 小球半径
x = r + 20  # 圆心横坐标和起始位置横坐标
y = r + 30  # 圆心纵坐标和起始位置纵坐标
x_speed = 4
y_speed = 3  # 横纵坐标速度

while cv2.waitKey(1) == -1:      # 按下任意键以后
    # 判断小球是否触碰画布边界
    if x > width - r or x < r:   # 如果圆的横坐标超出边界
        x_speed *= -1            # 横坐标速度取相反值
    if y > height - r or y < r:  # 如果圆的纵坐标超出边界
        y_speed *= -1            # 纵坐标速度取相反值
    # 绘图
    x += x_speed                 # 圆心按照横坐标速度移动
    y += y_speed                 # 圆心按照纵坐标速度移动
    canvas = np.ones([width, height, 3], dtype=np.uint8) * 255  # 创建白色画布
    canvas = cv2.circle(canvas, (x, y), r, (255, 0, 0), -1)  # 绘制圆形显示图像
    # 显示图像
    cv2.imshow('circle', canvas)
    time.sleep(1/60)  # 休眠1/60s,也就是每秒60帧

cv2.destroyAllWindows()







